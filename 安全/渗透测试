XSS攻击
概念：XSS是跨站脚本攻击(Cross Site Scripting)。恶意攻击者往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。如盗取用户 cookie、破坏页面结构、重定向到其他网站等。
本质是「对用户当前浏览的页面植入恶意脚本」。具体说，就是黑客为页面添加网站开发者意图之外的逻辑，其实现方式是在网站开发者提供的用于显示用户数据的地方加入脚本。

原理：向web页面插入js代码，让js代码可以被浏览器执行，访问该页面的用户则被攻击
被攻击的网站往往满足两个特征
1、具备表单元素
2、网站有漏洞，即，可以往表单元素插入存在 js 脚本的 html 元素。

分类：
1.反射型：通过get请求将js代码放在URL上，接受者是后端
	原理：攻击者在URL中插入xss代码，服务端将URL中的xss代码输出到页面上，攻击者将带有xss代码的URL发送给用户，用户打开后收到xss攻击
2.持久型：攻击者在页面上插入XSS代码，服务端将数据存到数据库或其他介质中，当用户访问页面时，服务端从数据库中取出数据展示到页面上，导致XSS代码执行，达到攻击效果
3.DOM型（基于文档对象模型）：通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。
	DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。
	原理：攻击者在URL中插入xss代码，前端页面将URL中的xss代码输出到页面上，攻击者将带有xss代码的URL发送给用户，用户打开后收到xss攻击
	攻击方式：1.使用document.write（）直接把内容输出到网页导致XSS漏洞。 
			2.使用innerHTML直接把内容输出至网页导致XSS漏洞。

防御：1.白名单过滤（设置允许存在的标签，不存在白名单的直接返回）；黑名单过滤（自己设定过滤的标签，函数str_place()、preg_replace()） 
	 2.编码（htmlspecialchars() 函数把预定义的字符转换为 HTML 实体，只转义 & 、" 、' 、< 、> ）（htmlentities 却会转化所有的html代码，连同里面的它无法识别的中文字符也会转化)当flag字段为不同的值时，可选。规定如何处理引号、无效的编码以及使用哪种文档类型） 
	 3.限制

工具：beef

参考链接：https://blog.csdn.net/qq_35393693/article/details/86597707
		https://zhuanlan.zhihu.com/p/26177815
		https://zhuanlan.zhihu.com/p/270988263

SQL注入
概念：通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。通常未经检查或者未经充分检查的用户输入数据或代码编写问题，意外变成了代码被执行。

注入点类型
数字型 1 or 1=1
字符型 admin' or 1=1 '
搜索型 测试%' union select 1,2,3,4 and '%'='

数据提交方式
get		post	cookie     http头部

执行效果
基于报错注入
基于布尔的盲注，根据返回页面判断条件真假的注入 1.' and 1=1	2.' and 1=2
	没有报错信息
	不管是正确的输入，还是错误的输入，都只显示两种情况（我们可以认为是1或者0）
	在正确的输入下，输入and 1=1/and 1=2可以发现判断
基于时间的盲注，不能根据页面返回内容判断任何信息（数据or错误信息），用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。
宽字节注入（原理即是利用编码转换，将服务器端强制添加的本来用于转义的\符号吃掉，从而能使攻击者输入的引号起到闭合作用，以至于可以进行SQL注入。）
联合查询，可以使用 union 的情况下的注入。（https://www.pianshen.com/article/4733313037/）
堆查询注入，可以同时执行多条语句的执行时的注入。（1' ; insert into users(id,username,password)values('101','lqs1','lqs1') --+）
ps：union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。

防护方法
1.永远不要信任用户的输入，对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等。 
2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 
3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 
4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。
5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装，把异常信息存放在独立的表中。

预编译好sql语句，python和Php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。

清晰的编程规范，结对/自动化代码 review ，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程 balabala）已经让 SQL 注入的风险变得非常低了。

参考链接：https://www.cnblogs.com/csguo/p/7499171.html
		https://zhuanlan.zhihu.com/p/58233754

CSRF（Cross Site Request Forgery）跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

分类
1.get类型
<img src="http://a.com/withdraw?amount=10000&for=hacker" >
在受害者访问含有这个 img 的页面后，浏览器会自动向 http://a.com 发出一次HTTP请求。http://a.com 就会收到包含受害者登录信息的一次跨域请求。
2.post类型
这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如：<form action="http://a.com/withdraw" method=POST>
    <input type="hidden" name="account" value="airing" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script>
访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。可见这种类型的 CSRF 与第一种一样，都是模拟请求，所以后端接口也不能将安全寄托在仅允许 POST 请求上。
3.链接型
通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：<a href="http://a.com/withdraw.php?amount=1000&for=hacker" taget="_blank">
 屠龙宝刀，点击就送！ 
<a/>
由于之前用户登录了信任的网站A，并且保存登录状态，只要用户主动访问上面的这个页面，则表示攻击成功。

防护
自动防御：阻止不明外域的访问
	同源检测
	Samesite Cookie
主动防御：提交时要求附加本域才能获取的信息
	Synchrogazer Tokens
	Double Cookie Defense
	Custom Header

参考链接：https://zhuanlan.zhihu.com/p/61827277

XXE注入，即XML External Entity，XML外部实体注入。通过 XML 实体，”SYSTEM”关键词导致 XML 解析器可以从本地文件或者远程 URI 中读取数据。所以攻击者可以通过 XML 实体传递自己构造的恶意值，是处理程序解析它。当引用外部实体时，通过构造恶意内容，可导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等危害。

类型
1.基础的XXE注入— 外部实体注入本地DTD
2.基于盲注的XXE注入—XML解析器在响应中不显示任何错误
3.基于错误的XXE注入—成功解析之后，XML解析器始终显示SAME响应。（即“您的消息已被接收”），因此，我们可能希望解析器将文件的内容“打印”到错误响应中

防护方法
1.使用开发语言提供的禁用外部实体的方法
2.过滤用户提交的XML数据

SSRF

文件上传