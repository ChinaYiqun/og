字符串
9. 回文数
8. 字符串转换整数 【难】
647. 回文子串
344. 反转字符串
28. 实现 strStr()
151. 翻转字符串里的单词
链表
		
206. 反转链表 
	注意  1 头结点
		  2 临时变量
21. 合并两个有序链表
141. 环形链表 [重点]

19.删除链表的倒数第N个节点
160. 相交链表 [重点]
	关键思路:
	while(p1!=p2):...
25. K 个一组翻转链表 【有点复杂而已】
148. 排序链表
	
142. 	环形链表 II
	关键思路:
	快慢指针 走到扣圈点
	慢指针不动 快指针重头走 再次相遇就是环形入口点
栈
	
20. 有效的括号
155. 最小栈
84 柱状图中最大的矩形  
85 最大矩形  
221. 最大正方形
剑指 Offer 09. 用两个栈实现队列 [重点]
	关键思路：
	入队列 l1.append
	出队列 分情况
		1.l1 l2 都为空
		2.l2 不为空
		3.while l1 不为空

队列

hash表
1. 两数之和   
138. 复制带随机指针的链表
149. 直线上最多的点数
347. 前 K 个高频元素 【重点】

树
剑指 Offer 34. 二叉树中和为某一值的路径
104. 二叉树的最大深度
102. 二叉树的层序遍历 【重点】
	三栈法
		stack 
		tmp1（当前层节点）
		tmp2 (下一层结点)	
	队列法
		import queue q = queue.Queue();q.put(),q.get() 
226. 翻转二叉树
236. 二叉树的最近公共祖先
堆
215.数组中的第K个最大元素
二叉树 的模板 （非递归） 【重点】


# def preorderTraversal(self, root: TreeNode) -> List[int]:
#         if root is None: return []
#         result = []
#         stack = [root]
#         while stack:
#             p = stack.pop()
#             if p is None:
#                 p = stack.pop()
#                 result.append(p.val)
#             else:
#                 if p.right: stack.append(p.right)  # 先append的最后访问
#                 if p.left: stack.append(p.left)
#                 stack.append(p)
#                 stack.append(None)
#         return result
二分法

33.搜索旋转排序数组【难】
69. x 的平方根		
153. 寻找旋转排序数组中的最小值
排序 

21.合并两个有序链表		 【归并排序 重点】
215.数组中的第K个最大元素  【快排 重点】
56. 合并区间				 【预排序】
88. 合并两个有序数组
148. 排序链表
138. 复制带随机指针的链表

动态规划

5.   最长回文子串 【难】
	Manacher 算法
53.  最大子序和
70.  爬楼梯
42.  接雨水
221. 最大正方形
72. 编辑距离
718. 最长重复子数组  
198. 打家劫舍
121. 买卖股票的最佳时机	【重点】
122. 买卖股票的最佳时机 II 
62.  不同路径
64.  最小路径和
	
322. 零钱兑换			【重点】
494. 目标和
416. 分割等和子集
518. 零钱兑换 II

递归
46. 全排列
22. 括号生成
17. 电话号码的字母组合
剑指 Offer 34. 二叉树中和为某一值的路径

50. Pow(x, n)

滑动窗口 多指针
3. 无重复字符的最长子串
11. 盛最多水的容器
26. 删除排序数组中的重复项
	
14. 最长公共前缀
167. 两数之和 II - 输入有序数组

贪心
55. 跳跃游戏
45. 跳跃游戏 II

位操作


剑指 Offer 65. 不用加减乘除做加法
class Solution:
    def add(self, a: int, b: int) -> int:
        x = 0xffffffff
        a, b = a & x, b & x
        while b != 0:
            a, b = (a ^ b), (a & b) << 1 & x
        return a if a <= 0x7fffffff else ~(a ^ x)

图
最短路径1










